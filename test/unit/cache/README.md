# DingoFS 单元测试编写

## 0. 核心需求

1. 阅读 `src/cache` 下的全部源码，深入理解其实现，并编写相对应的单元测试放到 `test/unit/cache` 目录下
2. 你需要单元测试能覆盖到所有的源码文件，尽可能确保测试的覆盖率
3. 测试需要尽可能考虑到各种 `case`，比如一个 `rpc` 调用成功或失败
4. 在编写完单测后，你需要完成编译，并运行所有的单元测试，确保所有单元测试都能顺利通过测试
5. 此外，在你编写测试用例后，我会直接在源码中以 `// REVIEW` 的特定方式提交一些 review 意见，你需要根据这些意见修改对应的实现，如：

```
// REVIEW: 删除这个测试用例
```

## 1. 代码规范

1. 测试文件中 `Author` 一律使用 `AI`, 注意 `Created Data` 和 `Copyright` 中的日期均为 `2026`
2. 所有测试用例的定义顺序最好和源码中函数的声明保持一致
3. 测试用例的命名要简明扼要，例如：
```
TEST_F(MDSClientTest, MDSClientStartAndShutdown)  // bad
TEST_F(MDSClientTest, StartAndShutdown)  // good
```
4. 一些测试的值需要更贴近现实，比如 member id:
```bash
member.id = 1  // bad
member.id = 044d4698-7bd4-4e44-9e94-aee6312ff06f  // good
```
5. mock 的文件需要放到 mock 目录下，方便其他测试用例需要使用到该类时，容易找到它，比如 common/mock 下
6. 在一个测试用例中，如果里面包含很多小的 case，你可以用 `{}` 把这些小的 case 包含起来，这样在看代码时会比较简洁明了
7. 测试中不要添加一些没必要的注释，有些不好理解的可以添加一些注释
8. 尽可能使用 C++11 的指定初始化器语法, 如（{.id=xxx, ...}）
9. 编写一个接口的单元测试时，尽可能放到一个测试用例中，如果一个接口的 2 个用例不相关，或者某一用例有过多的 `case`，这时候就需要考虑拆分

## 2. 关于编译
1. `test/unit/cache` 中每个单测文件都会生成一个单独的二进制，你需要参考 `test/unit/mds`，最终只生成一个二进制文件，通过 `--gtest_filter` 过滤运行
2. 编译时请带上 `-DCMAKE_EXPORT_COMPILE_COMMANDS=ON` 参数，这个参数可以使我在阅读代码时方便跳转

## 3. 关于运行
1. 如果在运行单测的过程中发现测试失败，最终分析是源码实现有问题，你需要修改对应的源码，而不是修改测试用例来适配错误的源码，但前提是修改源码后你需要争取我的同意。

## 4. 关于提交
1. 你需要参考该项目过往的提交规范，编写符合规范的 commit message

